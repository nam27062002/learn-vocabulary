{% extends "base.html" %} {% block title %}Th√™m Flashcard - Learn
English{%endblock %} {% block content %}
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>

<div class="add-flashcard-page">
  <div class="page-header">
    <h1>‚ûï Th√™m Flashcard M·ªõi</h1>
    <p>Th√™m t·ª´ v·ª±ng m·ªõi v√†o b·ªô s∆∞u t·∫≠p c·ªßa b·∫°n</p>
  </div>

  <style>
    .add-flashcard-page {
      max-width: 1000px;
      margin: 0 auto;
    }

    .page-header {
      text-align: center;
      margin-bottom: 40px;
      padding: 30px 0;
      border-bottom: 1px solid #3a3a5c;
    }

    .page-header h1 {
      font-size: 2.5em;
      margin-bottom: 10px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .page-header p {
      color: #b0b0b0;
      font-size: 1.1em;
    }

    .flashcard-container {
      margin-bottom: 40px;
    }

    .flashcard-section {
      background-color: #232345;
      border: 1px solid #3a3a5c;
      border-radius: 15px;
      padding: 25px;
      margin-bottom: 25px;
      position: relative;
      transition: all 0.3s ease;
    }

    .flashcard-section:hover {
      border-color: #667eea;
      box-shadow: 0 5px 20px rgba(102, 126, 234, 0.2);
    }

    .flashcard-section.sortable-chosen {
      box-shadow: 0 4px 16px rgba(102, 126, 234, 0.3);
      transform: scale(1.02);
    }

    .flashcard-section.sortable-ghost {
      opacity: 0.5;
    }

    .flashcard-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      color: #ffffff;
      font-size: 1.2em;
      font-weight: bold;
    }

    .card-number {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 8px 15px;
      border-radius: 50px;
      font-size: 0.9em;
    }

    .actions {
      display: flex;
      gap: 10px;
    }

    .action-icon {
      background: none;
      border: none;
      color: #888;
      font-size: 1.2em;
      cursor: pointer;
      padding: 5px;
      border-radius: 5px;
      transition: all 0.3s ease;
    }

    .action-icon:hover {
      color: #ff5252;
      background: rgba(255, 82, 82, 0.1);
    }

    .input-group {
      display: flex;
      gap: 20px;
      margin-bottom: 15px;
    }

    .input-field {
      flex: 1;
      display: flex;
      flex-direction: column;
      position: relative;
    }

    .input-field label {
      font-size: 0.9em;
      color: #b0b0b0;
      margin-bottom: 8px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .input-field input[type="text"],
    .input-field textarea {
      background-color: #3b3b5c;
      border: 1px solid #4a4a70;
      border-radius: 8px;
      padding: 15px;
      color: #ffffff;
      font-size: 1em;
      resize: vertical;
      min-height: 50px;
      transition: all 0.3s ease;
    }

    .input-field input[type="text"]:focus,
    .input-field textarea:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
    }

    .input-field input.correct-spelling,
    .input-field textarea.correct-spelling {
      color: #4caf50 !important;
      border-color: #4caf50;
    }

    .input-field input.incorrect-spelling,
    .input-field textarea.incorrect-spelling {
      color: #f44336 !important;
      border-color: #f44336;
    }

    .image-upload {
      width: 120px;
      height: 120px;
      border: 2px dashed #4a4a70;
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      text-align: center;
      color: #b0b0b0;
      font-size: 0.8em;
      margin-left: 20px;
      position: relative;
      overflow: hidden;
      transition: all 0.3s ease;
    }

    .image-upload:hover {
      border-color: #667eea;
      background: rgba(102, 126, 234, 0.05);
    }

    .image-upload img.preview {
      max-width: 100%;
      max-height: 100%;
      border-radius: 8px;
      position: absolute;
      top: 0;
      left: 0;
      object-fit: cover;
      width: 100%;
      height: 100%;
      z-index: 2;
    }

    .image-upload .image-upload-content {
      z-index: 3;
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
    }

    .image-upload .image-upload-content svg {
      width: 24px;
      height: 24px;
      fill: #b0b0b0;
    }

    .image-upload input[type="file"] {
      display: none;
    }

    .suggestions-list {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background-color: #3b3b5c;
      border: 1px solid #4a4a70;
      border-top: none;
      border-radius: 0 0 8px 8px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 10;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    .suggestion-item {
      padding: 12px 15px;
      cursor: pointer;
      color: #ffffff;
      border-bottom: 1px solid #4a4a70;
      transition: background 0.2s ease;
    }

    .suggestion-item:last-child {
      border-bottom: none;
    }

    .suggestion-item:hover {
      background-color: #4a4a70;
    }

    .button-group {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 30px;
    }

    .button {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #ffffff;
      border: none;
      border-radius: 8px;
      padding: 15px 30px;
      font-size: 1em;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: 500;
    }

    .button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
    }

    .save-section {
      text-align: center;
      margin-top: 40px;
      padding-top: 30px;
      border-top: 1px solid #3a3a5c;
    }

    .save-button {
      background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
      color: white;
      border: none;
      border-radius: 10px;
      padding: 15px 40px;
      font-size: 1.2em;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: 600;
      box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
    }

    .save-button:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(76, 175, 80, 0.4);
    }

    /* Modal Styles */
    .definition-modal {
      display: none;
      position: fixed;
      z-index: 20;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.7);
      justify-content: center;
      align-items: center;
    }

    .modal-content {
      background-color: #232345;
      margin: auto;
      padding: 30px;
      border-radius: 15px;
      width: 80%;
      max-width: 600px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      border: 1px solid #3a3a5c;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #4a4a70;
      padding-bottom: 15px;
      margin-bottom: 25px;
    }

    .modal-header h2 {
      margin: 0;
      color: #ffffff;
      font-size: 1.5em;
    }

    .close-button {
      color: #aaa;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      padding: 5px;
      border-radius: 5px;
      transition: all 0.3s ease;
    }

    .close-button:hover {
      color: #fff;
      background: rgba(255, 255, 255, 0.1);
    }

    .definition-options {
      max-height: 350px;
      overflow-y: auto;
      margin-bottom: 25px;
    }

    .definition-item {
      background-color: #3b3b5c;
      padding: 20px;
      margin-bottom: 15px;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      border: 1px solid #4a4a70;
    }

    .definition-item:hover {
      background-color: #4a4a70;
      border-color: #667eea;
      transform: translateY(-2px);
    }

    .definition-item p {
      margin: 0;
      color: #e0e0e0;
      line-height: 1.5;
    }

    .definition-item .part-of-speech {
      font-style: italic;
      color: #667eea;
      font-size: 0.9em;
      margin-bottom: 8px;
      font-weight: 500;
    }

    .auto-info {
      margin-top: 15px;
      display: flex;
      align-items: center;
      gap: 15px;
      padding: 10px 15px;
      background: rgba(102, 126, 234, 0.1);
      border-radius: 8px;
      border-left: 3px solid #667eea;
    }

    .auto-pos {
      color: #667eea;
      font-weight: 500;
      font-size: 0.9em;
    }

    .auto-audio {
      color: #667eea;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 5px;
      padding: 5px 10px;
      border-radius: 5px;
      transition: all 0.3s ease;
    }

    .auto-audio:hover {
      background: rgba(102, 126, 234, 0.2);
    }

    @media (max-width: 768px) {
      .input-group {
        flex-direction: column;
        gap: 15px;
      }

      .image-upload {
        margin-left: 0;
        width: 100%;
        height: 100px;
      }

      .modal-content {
        width: 90%;
        margin: 20px;
      }

      .page-header h1 {
        font-size: 2em;
      }
    }
  </style>

  <div class="flashcard-container" id="flashcard-container">
    <div class="flashcard-section" data-card-index="1">
      <div class="flashcard-header">
        <span class="card-number">1</span>
        <div class="actions">
          <button class="action-icon delete-card-btn" title="X√≥a th·∫ª">
            <svg
              width="22"
              height="22"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
              style="vertical-align: middle"
            >
              <polyline points="3 6 5 6 21 6" />
              <path
                d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2"
              />
              <line x1="10" y1="11" x2="10" y2="17" />
              <line x1="14" y1="11" x2="14" y2="17" />
            </svg>
          </button>
        </div>
      </div>
      <div style="display: flex; align-items: flex-end">
        <div class="input-group" style="flex-grow: 1">
          <div class="input-field">
            <label for="term1">THU·∫¨T NG·ªÆ</label>
            <input type="text" id="term1" name="term1" class="term-input" />
            <div
              id="suggestions1"
              class="suggestions-list"
              style="display: none"
            ></div>
          </div>
          <div class="input-field">
            <label for="definition1">ƒê·ªäNH NGHƒ®A</label>
            <textarea id="definition1" name="definition1"></textarea>
          </div>
        </div>
        <div class="image-upload" id="imageUpload1">
          <input type="file" accept="image/*" id="fileInput1" />
          <img class="preview" id="imgPreview1" style="display: none" />
          <button
            type="button"
            id="deleteImg1"
            style="
              position: absolute;
              top: 2px;
              right: 2px;
              z-index: 4;
              background: rgba(0, 0, 0, 0.3);
              border: none;
              border-radius: 50%;
              color: #fff;
              font-size: 16px;
              cursor: pointer;
              width: 22px;
              height: 22px;
              display: none;
              align-items: center;
              justify-content: center;
              line-height: 18px;
              padding: 0;
            "
          >
            &times;
          </button>
          <div class="image-upload-content">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
              <path d="M0 0h24v24H0z" fill="none" />
              <path
                d="M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-4.85 6.15l-3.3-3.3c-.2-.2-.5-.3-.75-.3s-.55.1-.75.3L6 11.15V15h8.4L19 10.45l-3.3-3.3c-.2-.2-.5-.3-.75-.3s-.55.1-.75.3z"
              />
            </svg>
            <span>H√¨nh ·∫£nh</span>
          </div>
        </div>
      </div>
      <div class="auto-info" style="margin-top: 8px; display: none">
        <span class="auto-pos" style="margin-right: 16px"></span>
        <span
          class="auto-audio"
          style="cursor: pointer; vertical-align: middle"
        ></span>
      </div>
      <div
        class="definition-suggestions"
        style="
          display: none;
          position: absolute;
          left: 0;
          right: 0;
          z-index: 10;
        "
      ></div>
    </div>
  </div>
  <div class="button-group">
    <button class="button">Th√™m th·∫ª</button>
  </div>
  <div class="save-section">
    <button id="saveAllFlashcardsBtn" class="save-button">
      üíæ L∆∞u t·∫•t c·∫£ Flashcards
    </button>
  </div>

  <!-- Definition Selection Modal -->
  <div id="definitionModal" class="definition-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Ch·ªçn ƒê·ªãnh Nghƒ©a</h2>
        <span class="close-button">&times;</span>
      </div>
      <div class="definition-options">
        <!-- Definitions will be loaded here by JavaScript -->
      </div>
      <div style="text-align: right">
        <button class="button" id="cancelDefinitionSelection">H·ªßy</button>
      </div>
    </div>
  </div>

  <script>
    document.addEventListener("DOMContentLoaded", function () {
      const termInputs = document.querySelectorAll(".term-input");
      const definitionModal = document.getElementById("definitionModal");
      const closeButton = definitionModal.querySelector(".close-button");
      const definitionOptionsContainer = definitionModal.querySelector(
        ".definition-options"
      );
      const cancelDefinitionSelectionButton = document.getElementById(
        "cancelDefinitionSelection"
      );

      let currentDefinitionTextarea = null; // To store the textarea linked to the current definition selection
      let fetchedWordDetails = null; // To store the full word details fetched from API

      closeButton.onclick = function () {
        definitionModal.style.display = "none";
      };
      cancelDefinitionSelectionButton.onclick = function () {
        definitionModal.style.display = "none";
      };
      window.onclick = function (event) {
        if (event.target == definitionModal) {
          definitionModal.style.display = "none";
        }
      };

      termInputs.forEach((input) => {
        const suggestionsBox = document.getElementById(
          `suggestions${input.id.replace("term", "")}`
        );

        input.addEventListener(
          "input",
          debounce(function () {
            const query = this.value.trim();

            // Reset color immediately when typing starts again
            this.classList.remove("correct-spelling", "incorrect-spelling");

            if (
              query.length > 0 &&
              !this.classList.contains("correct-spelling")
            ) {
              fetch(`/suggest-words/?q=${encodeURIComponent(query)}`)
                .then((response) => {
                  if (!response.ok) {
                    return response.json().catch(() => {
                      throw new Error(`HTTP error! status: ${response.status}`);
                    });
                  }
                  return response.json();
                })
                .then((data) => {
                  suggestionsBox.innerHTML = "";
                  if (data && data.error) {
                    suggestionsBox.style.display = "none";
                    return;
                  }
                  if (data.length > 0) {
                    data.forEach((word) => {
                      const suggestionItem = document.createElement("div");
                      suggestionItem.classList.add("suggestion-item");
                      suggestionItem.textContent = word;
                      suggestionItem.addEventListener("click", () => {
                        input.value = word;
                        suggestionsBox.style.display = "none";
                        checkSpelling(input);
                        // Trigger fetch definition and show modal
                        if (input.value.trim()) {
                          fetch(
                            `/word-details/?word=${encodeURIComponent(
                              input.value.trim()
                            )}`
                          )
                            .then((response) => {
                              if (!response.ok) {
                                return response.json().catch(() => {
                                  throw new Error(
                                    `HTTP error! status: ${response.status}`
                                  );
                                });
                              }
                              return response.json();
                            })
                            .then((data) => {
                              if (data && data.error) {
                                definitionInput.value = `L·ªói: ${data.error}`;
                                definitionInput.style.color = "#F44336";
                                return;
                              }
                              fetchedWordDetails = data;
                              definitionOptionsContainer.innerHTML = "";
                              let hasDefinitions = false;
                              if (data.meanings && data.meanings.length > 0) {
                                data.meanings.forEach((meaning) => {
                                  if (
                                    meaning.definitions &&
                                    meaning.definitions.length > 0
                                  ) {
                                    meaning.definitions.forEach(
                                      (def, index) => {
                                        hasDefinitions = true;
                                        const definitionItem =
                                          document.createElement("div");
                                        definitionItem.classList.add(
                                          "definition-item"
                                        );
                                        definitionItem.innerHTML = `
                                                                            ${
                                                                              meaning.part_of_speech
                                                                                ? `<p class=\"part-of-speech\">(${meaning.part_of_speech})</p>`
                                                                                : ""
                                                                            }
                                                                            <p>${
                                                                              def.en
                                                                            }</p>
                                                                        `;
                                        definitionItem.dataset.definitionIndex =
                                          index;
                                        definitionItem.dataset.meaningIndex =
                                          data.meanings.indexOf(meaning);
                                        definitionItem.addEventListener(
                                          "click",
                                          function () {
                                            const selectedMeaningIndex =
                                              parseInt(
                                                this.dataset.meaningIndex
                                              );
                                            const selectedDefinitionIndex =
                                              parseInt(
                                                this.dataset.definitionIndex
                                              );
                                            const selectedMeaning =
                                              fetchedWordDetails.meanings[
                                                selectedMeaningIndex
                                              ];
                                            const selectedDefinition =
                                              selectedMeaning.definitions[
                                                selectedDefinitionIndex
                                              ];
                                            let definitionText = `${selectedDefinition.en}`;
                                            definitionInput.value =
                                              definitionText.trim();
                                            definitionInput.style.color =
                                              "#ffffff";
                                            definitionModal.style.display =
                                              "none";
                                          }
                                        );
                                        definitionOptionsContainer.appendChild(
                                          definitionItem
                                        );
                                      }
                                    );
                                  }
                                });
                              }
                              if (hasDefinitions) {
                                currentDefinitionTextarea = definitionInput;
                                definitionModal.style.display = "flex";
                              } else {
                                definitionInput.value =
                                  "Kh√¥ng t√¨m th·∫•y ƒë·ªãnh nghƒ©a.";
                                definitionInput.style.color = "#b0b0b0";
                              }
                            })
                            .catch((error) => {
                              definitionInput.value = `L·ªói: ${
                                error.message || "Kh√¥ng th·ªÉ l·∫•y ƒë·ªãnh nghƒ©a."
                              }`;
                              definitionInput.style.color = "#F44336";
                            });
                        }
                      });
                      suggestionsBox.appendChild(suggestionItem);
                    });
                    suggestionsBox.style.display = "block";
                  } else {
                    suggestionsBox.style.display = "none";
                  }
                })
                .catch(() => {
                  suggestionsBox.style.display = "none";
                });
              checkSpelling(input);
            } else {
              suggestionsBox.style.display = "none";
              this.classList.remove("correct-spelling", "incorrect-spelling");
            }
          }, 300)
        );

        // Hide suggestions when input loses focus
        input.addEventListener("blur", function () {
          setTimeout(() => {
            suggestionsBox.style.display = "none";
          }, 100); // Small delay to allow click on suggestion item
        });

        // Function to prevent immediate hiding on click
        suggestionsBox.addEventListener("mousedown", function (event) {
          event.preventDefault();
        });

        // Listen for Enter key to fetch word details
        input.addEventListener("keydown", function (event) {
          if (event.key === "Enter") {
            event.preventDefault(); // Prevent form submission
            const word = this.value.trim();
            const definitionInput = document.getElementById(
              `definition${this.id.replace("term", "")}`
            );

            if (word) {
              fetch(`/word-details/?word=${encodeURIComponent(word)}`)
                .then((response) => {
                  if (!response.ok) {
                    return response.json().catch(() => {
                      throw new Error(`HTTP error! status: ${response.status}`);
                    });
                  }
                  return response.json();
                })
                .then((data) => {
                  if (data && data.error) {
                    console.error(
                      "Backend returned an error for word details:",
                      data.error
                    );
                    definitionInput.value = `L·ªói: ${data.error}`;
                    definitionInput.style.color = "#F44336"; // Red text for error
                    return;
                  }

                  fetchedWordDetails = data; // Store the fetched data

                  definitionOptionsContainer.innerHTML = ""; // Clear previous options
                  let hasDefinitions = false;

                  if (data.meanings && data.meanings.length > 0) {
                    data.meanings.forEach((meaning) => {
                      if (
                        meaning.definitions &&
                        meaning.definitions.length > 0
                      ) {
                        meaning.definitions.forEach((def, index) => {
                          hasDefinitions = true;
                          const definitionItem = document.createElement("div");
                          definitionItem.classList.add("definition-item");
                          definitionItem.innerHTML = `
                                                        ${
                                                          meaning.part_of_speech
                                                            ? `<p class=\"part-of-speech\">(${meaning.part_of_speech})</p>`
                                                            : ""
                                                        }
                                                        <p>${def.en}</p>
                                                    `;
                          // Store the full definition object for later use
                          definitionItem.dataset.definitionIndex = index;
                          definitionItem.dataset.meaningIndex =
                            data.meanings.indexOf(meaning);

                          definitionItem.addEventListener("click", function () {
                            const selectedMeaningIndex = parseInt(
                              this.dataset.meaningIndex
                            );
                            const selectedDefinitionIndex = parseInt(
                              this.dataset.definitionIndex
                            );

                            const selectedMeaning =
                              fetchedWordDetails.meanings[selectedMeaningIndex];
                            const selectedDefinition =
                              selectedMeaning.definitions[
                                selectedDefinitionIndex
                              ];

                            let definitionText = `${selectedDefinition.en}`;

                            currentDefinitionTextarea.value =
                              definitionText.trim();
                            currentDefinitionTextarea.style.color = "#ffffff";
                            definitionModal.style.display = "none"; // Close modal after selection
                          });
                          definitionOptionsContainer.appendChild(
                            definitionItem
                          );
                        });
                      }
                    });
                  }

                  if (hasDefinitions) {
                    currentDefinitionTextarea = definitionInput; // Set the target textarea
                    definitionModal.style.display = "flex"; // Show modal
                  } else {
                    definitionInput.value = "Kh√¥ng t√¨m th·∫•y ƒë·ªãnh nghƒ©a.";
                    definitionInput.style.color = "#b0b0b0";
                  }
                })
                .catch((error) => {
                  console.error("Error fetching word details:", error);
                  definitionInput.value = `L·ªói: ${
                    error.message || "Kh√¥ng th·ªÉ l·∫•y ƒë·ªãnh nghƒ©a."
                  }`;
                  definitionInput.style.color = "#F44336"; // Red text for error
                });
            } else {
              definitionInput.value = "";
              definitionInput.style.color = "#ffffff";
            }
          }
        });

        // Function to perform spell check
        function checkSpelling(inputElement) {
          const wordToCheck = inputElement.value.trim();
          if (wordToCheck.length > 0) {
            fetch("/check-spelling/", {
              method: "POST",
              headers: {
                "Content-Type": "application/x-www-form-urlencoded",
                "X-CSRFToken": getCookie("csrftoken"), // You need to get CSRF token
              },
              body: `word=${encodeURIComponent(wordToCheck)}`,
            })
              .then((response) => {
                if (!response.ok) {
                  return response.json().catch(() => {
                    throw new Error(`HTTP error! status: ${response.status}`);
                  });
                }
                return response.json();
              })
              .then((data) => {
                // Check if the data itself indicates an error from Django backend
                if (data && data.error) {
                  console.error(
                    "Backend returned an error for spell check:",
                    data.error
                  );
                  inputElement.classList.remove(
                    "correct-spelling",
                    "incorrect-spelling"
                  );
                  return; // Exit here
                }
                if (data.is_correct) {
                  inputElement.classList.remove("incorrect-spelling");
                  inputElement.classList.add("correct-spelling");
                } else {
                  inputElement.classList.remove("correct-spelling");
                  inputElement.classList.add("incorrect-spelling");
                }
              })
              .catch((error) => {
                console.error("Error checking spelling:", error);
                inputElement.classList.remove(
                  "correct-spelling",
                  "incorrect-spelling"
                ); // Reset color on error
              });
          }
        }
      });

      // Debounce function to limit how often a function is called
      function debounce(func, delay) {
        let timeout;
        return function (...args) {
          const context = this;
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(context, args), delay);
        };
      }

      // IMAGE UPLOAD LOGIC
      function setupImageUpload(
        imageUploadId,
        fileInputId,
        imgPreviewId,
        deleteBtnId
      ) {
        const imageUpload = document.getElementById(imageUploadId);
        const fileInput = document.getElementById(fileInputId);
        const imgPreview = document.getElementById(imgPreviewId);
        const deleteBtn = document.getElementById(deleteBtnId);
        const uploadContent = imageUpload.querySelector(
          ".image-upload-content"
        );

        imageUpload.addEventListener("click", function (e) {
          // ƒê·ª´ng trigger khi click v√†o n√∫t delete
          if (e.target === deleteBtn) return;
          fileInput.click();
        });

        fileInput.addEventListener("change", function (event) {
          const file = event.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = function (e) {
              imgPreview.src = e.target.result;
              imgPreview.style.display = "block";
              if (uploadContent) uploadContent.style.display = "none";
              if (deleteBtn) deleteBtn.style.display = "block";
            };
            reader.readAsDataURL(file);
          }
        });

        if (deleteBtn) {
          deleteBtn.addEventListener("click", function (e) {
            e.stopPropagation(); // Kh√¥ng trigger upload khi x√≥a
            imgPreview.src = "";
            imgPreview.style.display = "none";
            fileInput.value = "";
            if (uploadContent) uploadContent.style.display = "flex";
            deleteBtn.style.display = "none";
          });
          // ·∫®n n√∫t delete ban ƒë·∫ßu
          deleteBtn.style.display = "none";
        }
      }
      setupImageUpload(
        "imageUpload1",
        "fileInput1",
        "imgPreview1",
        "deleteImg1"
      );

      // ADD FLASHCARD LOGIC
      function reindexFlashcards() {
        const cards = document.querySelectorAll(".flashcard-section");
        cards.forEach((card, idx) => {
          const index = idx + 1;
          card.setAttribute("data-card-index", index);
          card.querySelector(".card-number").textContent = index;
          // Update input ids/names
          card.querySelector(".term-input").id = `term${index}`;
          card.querySelector(".term-input").name = `term${index}`;
          card.querySelector(".input-field textarea").id = `definition${index}`;
          card.querySelector(
            ".input-field textarea"
          ).name = `definition${index}`;
          card.querySelector(".suggestions-list").id = `suggestions${index}`;
          card.querySelector(".image-upload").id = `imageUpload${index}`;
          card.querySelector('input[type="file"]').id = `fileInput${index}`;
          card.querySelector("img.preview").id = `imgPreview${index}`;
          card.querySelector(
            'button[id^="deleteImg"]'
          ).id = `deleteImg${index}`;
        });
      }

      function initFlashcardSection(section) {
        // --- G·ª£i √Ω t·ª´, ki·ªÉm tra ch√≠nh t·∫£, ch·ªçn ƒë·ªãnh nghƒ©a ---
        const input = section.querySelector(".term-input");
        const suggestionsBox = section.querySelector(".suggestions-list");
        const definitionInput = section.querySelector("textarea");
        const cardIndex = section.getAttribute("data-card-index");

        // G·ª£i √Ω t·ª´
        input.addEventListener(
          "input",
          debounce(function () {
            const query = this.value.trim();
            this.classList.remove("correct-spelling", "incorrect-spelling");
            if (
              query.length > 0 &&
              !this.classList.contains("correct-spelling")
            ) {
              fetch(`/suggest-words/?q=${encodeURIComponent(query)}`)
                .then((response) => {
                  if (!response.ok) {
                    return response.json().catch(() => {
                      throw new Error(`HTTP error! status: ${response.status}`);
                    });
                  }
                  return response.json();
                })
                .then((data) => {
                  suggestionsBox.innerHTML = "";
                  if (data && data.error) {
                    suggestionsBox.style.display = "none";
                    return;
                  }
                  if (data.length > 0) {
                    data.forEach((word) => {
                      const suggestionItem = document.createElement("div");
                      suggestionItem.classList.add("suggestion-item");
                      suggestionItem.textContent = word;
                      suggestionItem.addEventListener("click", () => {
                        input.value = word;
                        suggestionsBox.style.display = "none";
                        checkSpelling(input);
                        // Trigger fetch definition and show modal
                        if (input.value.trim()) {
                          fetch(
                            `/word-details/?word=${encodeURIComponent(
                              input.value.trim()
                            )}`
                          )
                            .then((response) => {
                              if (!response.ok) {
                                return response.json().catch(() => {
                                  throw new Error(
                                    `HTTP error! status: ${response.status}`
                                  );
                                });
                              }
                              return response.json();
                            })
                            .then((data) => {
                              if (data && data.error) {
                                definitionInput.value = `L·ªói: ${data.error}`;
                                definitionInput.style.color = "#F44336";
                                return;
                              }
                              fetchedWordDetails = data;
                              definitionOptionsContainer.innerHTML = "";
                              let hasDefinitions = false;
                              if (data.meanings && data.meanings.length > 0) {
                                data.meanings.forEach((meaning) => {
                                  if (
                                    meaning.definitions &&
                                    meaning.definitions.length > 0
                                  ) {
                                    meaning.definitions.forEach(
                                      (def, index) => {
                                        hasDefinitions = true;
                                        const definitionItem =
                                          document.createElement("div");
                                        definitionItem.classList.add(
                                          "definition-item"
                                        );
                                        definitionItem.innerHTML = `
                                                                            ${
                                                                              meaning.part_of_speech
                                                                                ? `<p class=\"part-of-speech\">(${meaning.part_of_speech})</p>`
                                                                                : ""
                                                                            }
                                                                            <p>${
                                                                              def.en
                                                                            }</p>
                                                                        `;
                                        definitionItem.dataset.definitionIndex =
                                          index;
                                        definitionItem.dataset.meaningIndex =
                                          data.meanings.indexOf(meaning);
                                        definitionItem.addEventListener(
                                          "click",
                                          function () {
                                            const selectedMeaningIndex =
                                              parseInt(
                                                this.dataset.meaningIndex
                                              );
                                            const selectedDefinitionIndex =
                                              parseInt(
                                                this.dataset.definitionIndex
                                              );
                                            const selectedMeaning =
                                              fetchedWordDetails.meanings[
                                                selectedMeaningIndex
                                              ];
                                            const selectedDefinition =
                                              selectedMeaning.definitions[
                                                selectedDefinitionIndex
                                              ];
                                            let definitionText = `${selectedDefinition.en}`;
                                            definitionInput.value =
                                              definitionText.trim();
                                            definitionInput.style.color =
                                              "#ffffff";
                                            definitionModal.style.display =
                                              "none";
                                          }
                                        );
                                        definitionOptionsContainer.appendChild(
                                          definitionItem
                                        );
                                      }
                                    );
                                  }
                                });
                              }
                              if (hasDefinitions) {
                                currentDefinitionTextarea = definitionInput;
                                definitionModal.style.display = "flex";
                              } else {
                                definitionInput.value =
                                  "Kh√¥ng t√¨m th·∫•y ƒë·ªãnh nghƒ©a.";
                                definitionInput.style.color = "#b0b0b0";
                              }
                            })
                            .catch((error) => {
                              definitionInput.value = `L·ªói: ${
                                error.message || "Kh√¥ng th·ªÉ l·∫•y ƒë·ªãnh nghƒ©a."
                              }`;
                              definitionInput.style.color = "#F44336";
                            });
                        }
                      });
                      suggestionsBox.appendChild(suggestionItem);
                    });
                    suggestionsBox.style.display = "block";
                  } else {
                    suggestionsBox.style.display = "none";
                  }
                })
                .catch(() => {
                  suggestionsBox.style.display = "none";
                });
              checkSpelling(input);
            } else {
              suggestionsBox.style.display = "none";
              this.classList.remove("correct-spelling", "incorrect-spelling");
            }
          }, 300)
        );

        // Hide suggestions khi blur
        input.addEventListener("blur", function () {
          setTimeout(() => {
            suggestionsBox.style.display = "none";
          }, 100);
        });
        suggestionsBox.addEventListener("mousedown", function (event) {
          event.preventDefault();
        });

        // Enter ƒë·ªÉ l·∫•y ƒë·ªãnh nghƒ©a
        input.addEventListener("keydown", function (event) {
          if (event.key === "Enter") {
            event.preventDefault();
            if (input.value.trim()) {
              fetch(
                `/word-details/?word=${encodeURIComponent(input.value.trim())}`
              )
                .then((response) => {
                  if (!response.ok) {
                    return response.json().catch(() => {
                      throw new Error(`HTTP error! status: ${response.status}`);
                    });
                  }
                  return response.json();
                })
                .then((data) => {
                  if (data && data.error) {
                    definitionInput.value = `L·ªói: ${data.error}`;
                    definitionInput.style.color = "#F44336";
                    return;
                  }
                  fetchedWordDetails = data;
                  definitionOptionsContainer.innerHTML = "";
                  let hasDefinitions = false;
                  if (data.meanings && data.meanings.length > 0) {
                    data.meanings.forEach((meaning) => {
                      if (
                        meaning.definitions &&
                        meaning.definitions.length > 0
                      ) {
                        meaning.definitions.forEach((def, index) => {
                          hasDefinitions = true;
                          const definitionItem = document.createElement("div");
                          definitionItem.classList.add("definition-item");
                          definitionItem.innerHTML = `
                                                        ${
                                                          meaning.part_of_speech
                                                            ? `<p class=\"part-of-speech\">(${meaning.part_of_speech})</p>`
                                                            : ""
                                                        }
                                                        <p>${def.en}</p>
                                                    `;
                          definitionItem.dataset.definitionIndex = index;
                          definitionItem.dataset.meaningIndex =
                            data.meanings.indexOf(meaning);
                          definitionItem.addEventListener("click", function () {
                            const selectedMeaningIndex = parseInt(
                              this.dataset.meaningIndex
                            );
                            const selectedDefinitionIndex = parseInt(
                              this.dataset.definitionIndex
                            );
                            const selectedMeaning =
                              fetchedWordDetails.meanings[selectedMeaningIndex];
                            const selectedDefinition =
                              selectedMeaning.definitions[
                                selectedDefinitionIndex
                              ];
                            let definitionText = `${selectedDefinition.en}`;
                            definitionInput.value = definitionText.trim();
                            definitionInput.style.color = "#ffffff";
                            definitionModal.style.display = "none";
                          });
                          definitionOptionsContainer.appendChild(
                            definitionItem
                          );
                        });
                      }
                    });
                  }
                  if (hasDefinitions) {
                    currentDefinitionTextarea = definitionInput;
                    definitionModal.style.display = "flex";
                  } else {
                    definitionInput.value = "Kh√¥ng t√¨m th·∫•y ƒë·ªãnh nghƒ©a.";
                    definitionInput.style.color = "#b0b0b0";
                  }
                })
                .catch((error) => {
                  definitionInput.value = `L·ªói: ${
                    error.message || "Kh√¥ng th·ªÉ l·∫•y ƒë·ªãnh nghƒ©a."
                  }`;
                  definitionInput.style.color = "#F44336";
                });
            }
          }
        });

        // Ki·ªÉm tra ch√≠nh t·∫£
        function checkSpelling(inputElement) {
          const wordToCheck = inputElement.value.trim();
          if (wordToCheck.length > 0) {
            fetch("/check-spelling/", {
              method: "POST",
              headers: {
                "Content-Type": "application/x-www-form-urlencoded",
                "X-CSRFToken": getCookie("csrftoken"),
              },
              body: `word=${encodeURIComponent(wordToCheck)}`,
            })
              .then((response) => {
                if (!response.ok) {
                  return response.json().catch(() => {
                    throw new Error(`HTTP error! status: ${response.status}`);
                  });
                }
                return response.json();
              })
              .then((data) => {
                if (data.is_correct) {
                  inputElement.classList.remove("incorrect-spelling");
                  inputElement.classList.add("correct-spelling");
                } else {
                  inputElement.classList.remove("correct-spelling");
                  inputElement.classList.add("incorrect-spelling");
                }
              })
              .catch(() => {
                inputElement.classList.remove(
                  "correct-spelling",
                  "incorrect-spelling"
                );
              });
          }
        }
      }

      // Khi load trang, kh·ªüi t·∫°o cho th·∫ª ƒë·∫ßu ti√™n
      document
        .querySelectorAll(".flashcard-section")
        .forEach(initFlashcardSection);

      // Khi th√™m th·∫ª m·ªõi, KH√îNG th√™m drag handle n·ªØa
      function addFlashcard() {
        const container = document.getElementById("flashcard-container");
        const cards = container.querySelectorAll(".flashcard-section");
        const newIndex = cards.length + 1;
        const template = cards[0].cloneNode(true);
        // Reset input values
        template.querySelector(".term-input").value = "";
        template.querySelector(".input-field textarea").value = "";
        template.querySelector("img.preview").src = "";
        template.querySelector("img.preview").style.display = "none";
        template.querySelector('input[type="file"]').value = "";
        template.querySelector(".image-upload-content").style.display = "flex";
        template.querySelector('button[id^="deleteImg"]').style.display =
          "none";
        template.querySelector(".suggestions-list").innerHTML = "";
        template.querySelector(".suggestions-list").style.display = "none";
        container.appendChild(template);
        reindexFlashcards();
        initFlashcardSection(template);
        attachWordExistsCheck(template.querySelector(".term-input"));
        attachDefinitionSuggestionLogic(template);
        attachSpeakIconLogic(template);
        attachAutoInfoLogic(template);
      }
      document
        .querySelector(".button-group .button")
        .addEventListener("click", function (e) {
          if (this.textContent.trim() === "Th√™m th·∫ª") {
            e.preventDefault();
            addFlashcard();
          }
        });

      // Kh·ªüi t·∫°o SortableJS cho container, KH√îNG d√πng handle
      const flashcardContainer = document.getElementById("flashcard-container");
      new Sortable(flashcardContainer, {
        animation: 200,
        onEnd: function (evt) {
          reindexFlashcards();
        },
      });

      // Bi·∫øn cache l∆∞u d·ªØ li·ªáu API t·ª´ng t·ª´
      const wordApiCache = {};

      // Khi fetch chi ti·∫øt t·ª´ (v√≠ d·ª• trong logic autocomplete, enter...), l∆∞u v√†o cache
      function fetchWordDetailsAndCache(word, callback) {
        fetch(`/word-details/?word=${encodeURIComponent(word)}`)
          .then((res) => res.json())
          .then((data) => {
            wordApiCache[word.toLowerCase()] = data;
            if (callback) callback(data);
          });
      }

      document
        .getElementById("saveAllFlashcardsBtn")
        .addEventListener("click", function (e) {
          e.preventDefault();
          const cards = document.querySelectorAll(".flashcard-section");
          const formData = new FormData();
          cards.forEach((card, idx) => {
            const termInput = card.querySelector(".term-input");
            let word = termInput ? termInput.value.trim() : "";
            formData.append(`flashcards[${idx}][word]`, word);

            let posInput = card.querySelector(".part-of-speech-input");
            let part_of_speech = posInput ? posInput.value.trim() : "";

            let defTextarea = card.querySelector("textarea");
            let english_definition = defTextarea
              ? defTextarea.value.trim()
              : "";

            let audioInput = card.querySelector(".audio-url-input");
            let audio_url = audioInput ? audioInput.value.trim() : "";

            // N·∫øu thi·∫øu lo·∫°i t·ª´ ho·∫∑c audio_url th√¨ l·∫•y t·ª´ cache
            const cache = wordApiCache[word.toLowerCase()];
            if (cache) {
              if (!part_of_speech && cache.meanings && cache.meanings[0]) {
                part_of_speech = cache.meanings[0].part_of_speech || "";
              }
              if (!audio_url && cache.phonetics && cache.phonetics.length > 0) {
                // L·∫•y audio ƒë·∫ßu ti√™n c√≥ gi√° tr·ªã
                for (let ph of cache.phonetics) {
                  if (ph.audio) {
                    audio_url = ph.audio;
                    break;
                  }
                }
              }
            }
            formData.append(
              `flashcards[${idx}][part_of_speech]`,
              part_of_speech
            );
            formData.append(
              `flashcards[${idx}][english_definition]`,
              english_definition
            );
            formData.append(`flashcards[${idx}][audio_url]`, audio_url);

            const imgInput = card.querySelector(".image-input");
            if (imgInput && imgInput.files && imgInput.files[0]) {
              formData.append(`flashcards[${idx}][image]`, imgInput.files[0]);
            }
          });
          fetch("/api/save-flashcards/", {
            method: "POST",
            headers: {
              "X-CSRFToken": getCookie("csrftoken"),
            },
            body: formData,
          })
            .then((res) => res.json())
            .then((data) => {
              if (data.success) {
                alert("L∆∞u th√†nh c√¥ng!");
              } else {
                alert("L·ªói: " + (data.error || "Kh√¥ng l∆∞u ƒë∆∞·ª£c!"));
              }
            })
            .catch((err) => {
              alert("L·ªói k·∫øt n·ªëi server!");
            });
        });

      function showWordExistsError(input, show) {
        let err = input.parentNode.querySelector(".word-exists-error");
        if (!err && show) {
          err = document.createElement("div");
          err.className = "word-exists-error";
          err.style.color = "#ff5252";
          err.style.fontSize = "0.95em";
          err.style.marginTop = "4px";
          err.textContent = "T·ª´ n√†y ƒë√£ t·ªìn t·∫°i trong h·ªá th·ªëng!";
          input.parentNode.appendChild(err);
        }
        if (err) err.style.display = show ? "block" : "none";
        input.style.borderColor = show ? "#ff5252" : "";
      }

      function attachWordExistsCheck(input) {
        input.addEventListener(
          "input",
          debounce(function () {
            const word = this.value.trim();
            if (!word) {
              showWordExistsError(this, false);
              return;
            }
            fetch(`/api/check-word-exists/?word=${encodeURIComponent(word)}`)
              .then((res) => res.json())
              .then((data) => {
                showWordExistsError(this, data.exists);
              });
          }, 300)
        );
      }

      document.querySelectorAll(".term-input").forEach(attachWordExistsCheck);

      function attachDefinitionSuggestionLogic(section) {
        const termInput = section.querySelector(".term-input");
        const defTextarea = section.querySelector("textarea");
        const suggestionBox = section.querySelector(".definition-suggestions");
        let currentSuggestions = [];
        let suggestionVisible = false;

        // Helper: ki·ªÉm tra ch√≠nh t·∫£ (d·ª±a v√†o class correct-spelling)
        function isTermCorrect() {
          return termInput.classList.contains("correct-spelling");
        }

        // Hi·ªÉn th·ªã g·ª£i √Ω ƒë·ªãnh nghƒ©a
        function showSuggestions(defs) {
          suggestionBox.innerHTML = "";
          if (!defs || defs.length === 0) {
            suggestionBox.style.display = "none";
            suggestionVisible = false;
            return;
          }
          defs.forEach((item) => {
            const div = document.createElement("div");
            div.className = "definition-suggestion-item";
            div.innerHTML =
              (item.part_of_speech
                ? `<span style="color:#b0b0ff;font-style:italic;">(${item.part_of_speech})</span> `
                : "") + item.en;
            div.addEventListener("mousedown", function (e) {
              e.preventDefault();
              defTextarea.value = item.en;
              suggestionBox.style.display = "none";
              suggestionVisible = false;
            });
            suggestionBox.appendChild(div);
          });
          suggestionBox.style.display = "block";
          suggestionVisible = true;
        }

        // Khi focus v√†o textarea ƒë·ªãnh nghƒ©a
        defTextarea.addEventListener("focus", function () {
          if (!isTermCorrect()) {
            suggestionBox.style.display = "none";
            suggestionVisible = false;
            return;
          }
          const word = termInput.value.trim();
          if (!word) return;
          // L·∫•y t·ª´ cache n·∫øu c√≥
          const cache = wordApiCache[word.toLowerCase()];
          if (cache && cache.meanings) {
            let defs = [];
            cache.meanings.forEach((m) => {
              if (m.definitions && m.definitions.length > 0) {
                m.definitions.forEach((d) => {
                  defs.push({
                    en: d.en,
                    part_of_speech: m.part_of_speech || "",
                  });
                });
              }
            });
            showSuggestions(defs);
          } else {
            // N·∫øu ch∆∞a c√≥ cache, fetch v√† cache l·∫°i
            fetchWordDetailsAndCache(word, function (data) {
              let defs = [];
              if (data && data.meanings) {
                data.meanings.forEach((m) => {
                  if (m.definitions && m.definitions.length > 0) {
                    m.definitions.forEach((d) => {
                      defs.push({
                        en: d.en,
                        part_of_speech: m.part_of_speech || "",
                      });
                    });
                  }
                });
              }
              showSuggestions(defs);
            });
          }
        });
        // ·∫®n suggestion khi blur textarea (delay ƒë·ªÉ b·∫Øt s·ª± ki·ªán click ch·ªçn)
        defTextarea.addEventListener("blur", function () {
          setTimeout(() => {
            suggestionBox.style.display = "none";
            suggestionVisible = false;
          }, 200);
        });
      }

      function attachSpeakIconLogic(section) {
        const termInput = section.querySelector(".term-input");
        const defTextarea = section.querySelector("textarea");
        const speakIcon = section.querySelector(".speak-icon");
        if (!speakIcon) return;
        // Hi·ªán/·∫©n icon loa
        function updateSpeakIcon() {
          const word = termInput.value.trim();
          const definition = defTextarea.value.trim();
          if (
            word &&
            definition &&
            termInput.classList.contains("correct-spelling")
          ) {
            speakIcon.style.display = "inline-block";
          } else {
            speakIcon.style.display = "none";
          }
        }
        termInput.addEventListener("input", updateSpeakIcon);
        defTextarea.addEventListener("input", updateSpeakIcon);
        termInput.addEventListener("blur", updateSpeakIcon);
        termInput.addEventListener("change", updateSpeakIcon);
        defTextarea.addEventListener("blur", updateSpeakIcon);
        // X·ª≠ l√Ω khi b·∫•m icon loa
        speakIcon.addEventListener("click", function () {
          const word = termInput.value.trim();
          if (!word) return;
          const cache = wordApiCache[word.toLowerCase()];
          let audioUrl = "";
          let partOfSpeech = "";
          let phonetic = "";
          if (cache) {
            // L·∫•y audio ƒë·∫ßu ti√™n c√≥ gi√° tr·ªã
            if (cache.phonetics && cache.phonetics.length > 0) {
              for (let ph of cache.phonetics) {
                if (ph.audio) {
                  audioUrl = ph.audio;
                  break;
                }
              }
              for (let ph of cache.phonetics) {
                if (ph.text) {
                  phonetic = ph.text;
                  break;
                }
              }
            }
            if (cache.meanings && cache.meanings.length > 0) {
              partOfSpeech = cache.meanings[0].part_of_speech || "";
            }
          }
          if (audioUrl) {
            const audio = new Audio(audioUrl);
            audio.play();
          } else {
            // ƒê·ªçc b·∫±ng Web Speech API
            let text = word;
            if (partOfSpeech) text += ", " + partOfSpeech;
            if (phonetic) text += ", " + phonetic;
            if ("speechSynthesis" in window) {
              const utter = new SpeechSynthesisUtterance(text);
              utter.lang = "en-US";
              window.speechSynthesis.speak(utter);
            } else {
              alert("Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ ƒë·ªçc t·ª´!");
            }
          }
        });
        // L·∫ßn ƒë·∫ßu ki·ªÉm tra
        updateSpeakIcon();
      }

      function attachAutoInfoLogic(section) {
        const termInput = section.querySelector(".term-input");
        const defTextarea = section.querySelector("textarea");
        const autoInfo = section.querySelector(".auto-info");
        const autoPos = section.querySelector(".auto-pos");
        const autoAudio = section.querySelector(".auto-audio");
        function updateAutoInfo() {
          const word = termInput.value.trim();
          const definition = defTextarea.value.trim();
          if (
            word &&
            definition &&
            termInput.classList.contains("correct-spelling")
          ) {
            const cache = wordApiCache[word.toLowerCase()];
            let partOfSpeech = "";
            let audioUrl = "";
            let phonetic = "";
            if (cache) {
              if (cache.meanings && cache.meanings.length > 0) {
                partOfSpeech = cache.meanings[0].part_of_speech || "";
              }
              if (cache.phonetics && cache.phonetics.length > 0) {
                for (let ph of cache.phonetics) {
                  if (ph.audio) {
                    audioUrl = ph.audio;
                    break;
                  }
                }
                for (let ph of cache.phonetics) {
                  if (ph.text) {
                    phonetic = ph.text;
                    break;
                  }
                }
              }
            }
            autoPos.textContent = partOfSpeech
              ? `Lo·∫°i t·ª´: ${partOfSpeech}`
              : "";
            if (audioUrl) {
              autoAudio.innerHTML = `<svg width='22' height='22' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polygon points='11 5 6 9 2 9 2 15 6 15 11 19 11 5'></polygon><path d='M19.07 4.93a10 10 0 0 1 0 14.14'></path><path d='M15.54 8.46a5 5 0 0 1 0 7.07'></path></svg>`;
              autoAudio.title = "Nghe ph√°t √¢m";
              autoAudio.onclick = function () {
                const audio = new Audio(audioUrl);
                audio.play();
              };
            } else if (word) {
              autoAudio.innerHTML = `<svg width='22' height='22' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polygon points='11 5 6 9 2 9 2 15 6 15 11 19 11 5'></polygon><path d='M19.07 4.93a10 10 0 0 1 0 14.14'></path><path d='M15.54 8.46a5 5 0 0 1 0 7.07'></path></svg>`;
              autoAudio.title = "ƒê·ªçc t·ª´ b·∫±ng tr√¨nh duy·ªát";
              autoAudio.onclick = function () {
                let text = word;
                if (partOfSpeech) text += ", " + partOfSpeech;
                if (phonetic) text += ", " + phonetic;
                if ("speechSynthesis" in window) {
                  const utter = new SpeechSynthesisUtterance(text);
                  utter.lang = "en-US";
                  window.speechSynthesis.speak(utter);
                } else {
                  alert("Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ ƒë·ªçc t·ª´!");
                }
              };
            } else {
              autoAudio.innerHTML = "";
              autoAudio.onclick = null;
            }
            autoInfo.style.display =
              partOfSpeech || audioUrl ? "block" : "none";
          } else {
            autoInfo.style.display = "none";
          }
        }
        termInput.addEventListener("input", updateAutoInfo);
        defTextarea.addEventListener("input", updateAutoInfo);
        termInput.addEventListener("blur", updateAutoInfo);
        termInput.addEventListener("change", updateAutoInfo);
        defTextarea.addEventListener("blur", updateAutoInfo);
        updateAutoInfo();
      }

      // Khi load trang, g·∫Øn logic cho t·∫•t c·∫£ th·∫ª
      setTimeout(() => {
        document
          .querySelectorAll(".flashcard-section")
          .forEach(attachDefinitionSuggestionLogic);
        document
          .querySelectorAll(".flashcard-section")
          .forEach(attachSpeakIconLogic);
        document
          .querySelectorAll(".flashcard-section")
          .forEach(attachAutoInfoLogic);
      }, 0);
    });

    function getCookie(name) {
      let cookieValue = null;
      if (document.cookie && document.cookie !== "") {
        const cookies = document.cookie.split(";");
        for (let i = 0; i < cookies.length; i++) {
          const cookie = cookies[i].trim();
          if (cookie.substring(0, name.length + 1) === name + "=") {
            cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
            break;
          }
        }
      }
      return cookieValue;
    }
  </script>
</div>
{% endblock %}
