{% extends "base.html" %} {% load i18n %} {% block title %}{% trans "Add Flashcard" %} - {% trans "Learn English" %}{% endblock %} {% block content %} {%
csrf_token %}
<meta name="csrf-token" content="{{ csrf_token }}" />
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>

<div class="add-flashcard-page">
  <div class="page-header">
    <h1>‚ûï {% trans "Add New Flashcard" %}</h1>
    <p>{% trans "Add new vocabulary to your collection" %}</p>
  </div>

  <style>
    .add-flashcard-page {
      max-width: 1000px;
      margin: 0 auto;
    }

    .page-header {
      text-align: center;
      margin-bottom: 40px;
      padding: 30px 0;
      border-bottom: 1px solid #3a3a5c;
    }

    .page-header h1 {
      font-size: 2.5em;
      margin-bottom: 10px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .page-header p {
      color: #b0b0b0;
      font-size: 1.1em;
    }

    .flashcard-container {
      margin-bottom: 40px;
    }

    .flashcard-section {
      background-color: #232345;
      border: 1px solid #3a3a5c;
      border-radius: 15px;
      padding: 25px;
      margin-bottom: 25px;
      position: relative;
      transition: all 0.3s ease;
    }

    .flashcard-section:hover {
      border-color: #667eea;
      box-shadow: 0 5px 20px rgba(102, 126, 234, 0.2);
    }

    .flashcard-section.sortable-chosen {
      box-shadow: 0 4px 16px rgba(102, 126, 234, 0.3);
      transform: scale(1.02);
    }

    .flashcard-section.sortable-ghost {
      opacity: 0.5;
    }

    .flashcard-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      color: #ffffff;
      font-size: 1.2em;
      font-weight: bold;
    }

    .card-number {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 8px 15px;
      border-radius: 50px;
      font-size: 0.9em;
    }

    .actions {
      display: flex;
      gap: 10px;
    }

    .action-icon {
      background: none;
      border: none;
      color: #888;
      font-size: 1.2em;
      cursor: pointer;
      padding: 5px;
      border-radius: 5px;
      transition: all 0.3s ease;
    }

    .action-icon:hover {
      color: #ff5252;
      background: rgba(255, 82, 82, 0.1);
    }

    .drag-handle {
      cursor: grab;
    }

    .drag-handle:hover {
      color: #667eea !important;
      background: rgba(102, 126, 234, 0.1) !important;
    }

    .drag-handle:active {
      cursor: grabbing;
    }

    .input-group {
      display: flex;
      gap: 20px;
      margin-bottom: 15px;
    }

    .input-field {
      flex: 1;
      display: flex;
      flex-direction: column;
      position: relative;
    }

    .input-field label {
      font-size: 0.9em;
      color: #b0b0b0;
      margin-bottom: 8px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .input-field input[type="text"],
    .input-field textarea {
      background-color: #3b3b5c;
      border: 1px solid #4a4a70;
      border-radius: 8px;
      padding: 15px;
      color: #ffffff;
      font-size: 1em;
      resize: vertical;
      min-height: 50px;
      transition: all 0.3s ease;
    }

    .input-field input[type="text"]:focus,
    .input-field textarea:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
    }

    .input-field input.correct-spelling,
    .input-field textarea.correct-spelling {
      color: #4caf50 !important;
      border-color: #4caf50;
    }

    .input-field input.incorrect-spelling,
    .input-field textarea.incorrect-spelling {
      color: #f44336 !important;
      border-color: #f44336;
    }

    .image-upload {
      width: 120px;
      height: 120px;
      border: 2px dashed #4a4a70;
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      text-align: center;
      color: #b0b0b0;
      font-size: 0.8em;
      margin-left: 20px;
      position: relative;
      overflow: hidden;
      transition: all 0.3s ease;
    }

    .image-upload:hover {
      border-color: #667eea;
      background: rgba(102, 126, 234, 0.05);
    }

    .image-upload img.preview {
      max-width: 100%;
      max-height: 100%;
      border-radius: 8px;
      position: absolute;
      top: 0;
      left: 0;
      object-fit: cover;
      width: 100%;
      height: 100%;
      z-index: 2;
    }

    .image-upload .image-upload-content {
      z-index: 3;
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
    }

    .image-upload .image-upload-content svg {
      width: 24px;
      height: 24px;
      fill: #b0b0b0;
    }

    .image-upload input[type="file"] {
      display: none;
    }

    .suggestions-list {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background-color: #3b3b5c;
      border: 1px solid #4a4a70;
      border-top: none;
      border-radius: 0 0 8px 8px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 10;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    .suggestion-item {
      padding: 12px 15px;
      cursor: pointer;
      color: #ffffff;
      border-bottom: 1px solid #4a4a70;
      transition: background 0.2s ease;
    }

    .suggestion-item:last-child {
      border-bottom: none;
    }

    .suggestion-item:hover {
      background-color: #4a4a70;
    }

    .button-group {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 30px;
    }

    .button {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #ffffff;
      border: none;
      border-radius: 8px;
      padding: 15px 30px;
      font-size: 1em;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: 500;
    }

    .button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
    }

    .save-section {
      text-align: center;
      margin-top: 40px;
      padding-top: 30px;
      border-top: 1px solid #3a3a5c;
    }

    .save-button {
      background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
      color: white;
      border: none;
      border-radius: 10px;
      padding: 15px 40px;
      font-size: 1.2em;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: 600;
      box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
    }

    .save-button:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(76, 175, 80, 0.4);
    }



    .auto-info {
      margin-top: 15px;
      display: flex;
      align-items: center;
      gap: 15px;
      padding: 10px 15px;
      background: rgba(102, 126, 234, 0.1);
      border-radius: 8px;
      border-left: 3px solid #667eea;
    }

    .auto-pos {
      color: #667eea;
      font-weight: 500;
      font-size: 0.9em;
    }

    .auto-audio {
      color: #667eea;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 5px;
      padding: 5px 10px;
      border-radius: 5px;
      transition: all 0.3s ease;
    }

    .auto-audio:hover {
      background: rgba(102, 126, 234, 0.2);
    }

    /* Definition Suggestions Styling */
    .definition-suggestion-item {
      padding: 12px 15px;
      cursor: pointer;
      color: #ffffff;
      border-bottom: 1px solid #4a4a70;
      transition: background 0.2s ease;
      line-height: 1.4;
    }

    .definition-suggestion-item:last-child {
      border-bottom: none;
    }

    .definition-suggestion-item:hover {
      background-color: #4a4a70;
    }

    @media (max-width: 768px) {
      .input-group {
        flex-direction: column;
        gap: 15px;
      }

      .image-upload {
        margin-left: 0;
        width: 100%;
        height: 100px;
      }

      .modal-content {
        width: 90%;
        margin: 20px;
      }

      .page-header h1 {
        font-size: 2em;
      }
    }
  </style>

  <div class="flashcard-container" id="flashcard-container">
    <div class="flashcard-section" data-card-index="1">
      <div class="flashcard-header">
        <span class="card-number">1</span>
        <div class="actions">
          <button class="action-icon drag-handle" title="K√©o ƒë·ªÉ di chuy·ªÉn th·∫ª">
            <svg
              width="22"
              height="22"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
              style="vertical-align: middle"
            >
              <line x1="3" y1="6" x2="21" y2="6" />
              <line x1="3" y1="12" x2="21" y2="12" />
              <line x1="3" y1="18" x2="21" y2="18" />
            </svg>
          </button>
          <button class="action-icon delete-card-btn" title="X√≥a th·∫ª">
            <svg
              width="22"
              height="22"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
              style="vertical-align: middle"
            >
              <polyline points="3 6 5 6 21 6" />
              <path
                d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2"
              />
              <line x1="10" y1="11" x2="10" y2="17" />
              <line x1="14" y1="11" x2="14" y2="17" />
            </svg>
          </button>
        </div>
      </div>
      <div style="display: flex; align-items: flex-end">
        <div class="input-group" style="flex-grow: 1">
          <div class="input-field">
            <label for="term1">THU·∫¨T NG·ªÆ</label>
            <input type="text" id="term1" name="term1" class="term-input" />
            <div
              id="suggestions1"
              class="suggestions-list"
              style="display: none"
            ></div>
          </div>
        </div>
        <div class="image-upload" id="imageUpload1">
          <input type="file" accept="image/*" id="fileInput1" />
          <img class="preview" id="imgPreview1" style="display: none" />
          <button
            type="button"
            id="deleteImg1"
            style="
              position: absolute;
              top: 2px;
              right: 2px;
              z-index: 4;
              background: rgba(0, 0, 0, 0.3);
              border: none;
              border-radius: 50%;
              color: #fff;
              font-size: 16px;
              cursor: pointer;
              width: 22px;
              height: 22px;
              display: none;
              align-items: center;
              justify-content: center;
              line-height: 18px;
              padding: 0;
            "
          >
            &times;
          </button>
          <div class="image-upload-content">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
              <path d="M0 0h24v24H0z" fill="none" />
              <path
                d="M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-4.85 6.15l-3.3-3.3c-.2-.2-.5-.3-.75-.3s-.55.1-.75.3L6 11.15V15h8.4L19 10.45l-3.3-3.3c-.2-.2-.5-.3-.75-.3s-.55.1-.75.3z"
              />
            </svg>
            <span>H√¨nh ·∫£nh</span>
          </div>
        </div>
      </div>
      <div class="auto-info" style="margin-top: 8px; display: none">
        <span class="auto-pos" style="margin-right: 16px"></span>
        <span
          class="auto-audio"
          style="cursor: pointer; vertical-align: middle"
        ></span>
      </div>

      <!-- Definitions moved below auto-info -->
      <div class="input-field" style="position: relative; margin-top: 15px">
        <label for="definition1">ƒê·ªäNH NGHƒ®A (ENGLISH)</label>
        <textarea
          id="definition1"
          name="definition1"
          placeholder="English definition will appear here..."
        ></textarea>
        <div
          class="definition-suggestions"
          style="
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            z-index: 10;
            background-color: #3b3b5c;
            border: 1px solid #4a4a70;
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 200px;
            overflow-y: auto;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
          "
        ></div>
      </div>
      <div class="input-field" style="margin-top: 15px">
        <label for="vietnamese_definition1">ƒê·ªäNH NGHƒ®A (TI·∫æNG VI·ªÜT)</label>
        <textarea
          id="vietnamese_definition1"
          name="vietnamese_definition1"
          placeholder="Vietnamese definition will auto-translate..."
        ></textarea>
      </div>
    </div>
  </div>
  <div class="button-group">
    <button class="button">Th√™m th·∫ª</button>
  </div>
  <div class="save-section">
    <button id="saveAllFlashcardsBtn" class="save-button">
      üíæ L∆∞u t·∫•t c·∫£ Flashcards
    </button>
  </div>



  <script>
    document.addEventListener("DOMContentLoaded", function () {
      const termInputs = document.querySelectorAll(".term-input");

      termInputs.forEach((input) => {
        const suggestionsBox = document.getElementById(
          `suggestions${input.id.replace("term", "")}`
        );

        input.addEventListener(
          "input",
          debounce(function () {
            const query = this.value.trim();

            // Reset color immediately when typing starts again
            this.classList.remove("correct-spelling", "incorrect-spelling");

            // Ch·ªâ hi·ªán g·ª£i √Ω khi c√≥ focus v√† t·ª´ ch∆∞a ƒë√∫ng ch√≠nh t·∫£
            if (query.length > 0 && document.activeElement === this) {
              fetch(`/suggest-words/?q=${encodeURIComponent(query)}`)
                .then((response) => {
                  if (!response.ok) {
                    return response.json().catch(() => {
                      throw new Error(`HTTP error! status: ${response.status}`);
                    });
                  }
                  return response.json();
                })
                .then((data) => {
                  // Ki·ªÉm tra l·∫°i: ch·ªâ hi·ªán g·ª£i √Ω n·∫øu v·∫´n focus v√† ch∆∞a ƒë√∫ng ch√≠nh t·∫£
                  if (
                    document.activeElement !== this ||
                    this.classList.contains("correct-spelling")
                  ) {
                    suggestionsBox.style.display = "none";
                    return;
                  }

                  suggestionsBox.innerHTML = "";
                  if (data && data.error) {
                    suggestionsBox.style.display = "none";
                    return;
                  }
                  if (data.length > 0) {
                    data.forEach((word) => {
                      const suggestionItem = document.createElement("div");
                      suggestionItem.classList.add("suggestion-item");
                      suggestionItem.textContent = word;
                      suggestionItem.addEventListener("click", () => {
                        input.value = word;
                        suggestionsBox.style.display = "none";
                        checkSpelling(input);
                        // Auto-fetch first definition directly
                        const definitionInput = document.getElementById(
                          `definition${input.id.replace("term", "")}`
                        );
                        if (input.value.trim()) {
                          fetch(
                            `/word-details/?word=${encodeURIComponent(
                              input.value.trim()
                            )}`
                          )
                            .then((response) => {
                              if (!response.ok) {
                                return response.json().catch(() => {
                                  throw new Error(
                                    `HTTP error! status: ${response.status}`
                                  );
                                });
                              }
                              return response.json();
                            })
                            .then((data) => {
                              if (data && data.error) {
                                definitionInput.value = `L·ªói: ${data.error}`;
                                definitionInput.style.color = "#F44336";
                                return;
                              }
                              
                              // Get first definition directly
                              let firstDefinition = "";
                              if (data.meanings && data.meanings.length > 0) {
                                const firstMeaning = data.meanings[0];
                                if (firstMeaning.definitions && firstMeaning.definitions.length > 0) {
                                  firstDefinition = firstMeaning.definitions[0].en;
                                }
                              }

                              if (firstDefinition) {
                                definitionInput.value = firstDefinition.trim();
                                definitionInput.style.color = "#ffffff";

                                // Auto-translate to Vietnamese
                                const cardNumber = input.id.replace("term", "");
                                const vietnameseTextarea = document.getElementById(
                                  `vietnamese_definition${cardNumber}`
                                );
                                if (vietnameseTextarea) {
                                  translateToVietnamese(firstDefinition.trim(), vietnameseTextarea);
                                }
                              } else {
                                definitionInput.value = "Kh√¥ng t√¨m th·∫•y ƒë·ªãnh nghƒ©a.";
                                definitionInput.style.color = "#b0b0b0";
                              }
                            })
                            .catch((error) => {
                              definitionInput.value = `L·ªói: ${
                                error.message || "Kh√¥ng th·ªÉ l·∫•y ƒë·ªãnh nghƒ©a."
                              }`;
                              definitionInput.style.color = "#F44336";
                            });
                        }
                      });
                      suggestionsBox.appendChild(suggestionItem);
                    });
                    suggestionsBox.style.display = "block";
                  } else {
                    suggestionsBox.style.display = "none";
                  }
                })
                .catch(() => {
                  suggestionsBox.style.display = "none";
                });
              checkSpelling(input);
            } else {
              suggestionsBox.style.display = "none";
              this.classList.remove("correct-spelling", "incorrect-spelling");
            }
          }, 300)
        );

        // Hide suggestions when input loses focus - ·∫©n ngay l·∫≠p t·ª©c n·∫øu m·∫•t focus
        input.addEventListener("blur", function () {
          // Delay ng·∫Øn ƒë·ªÉ cho ph√©p click v√†o suggestion
          setTimeout(() => {
            // Ki·ªÉm tra n·∫øu kh√¥ng focus v√†o input ho·∫∑c suggestions th√¨ ·∫©n ƒëi
            if (
              document.activeElement !== this &&
              !suggestionsBox.contains(document.activeElement)
            ) {
              suggestionsBox.style.display = "none";
            }
          }, 150);
        });

        // Show suggestions khi focus l·∫°i (n·∫øu t·ª´ ch∆∞a ƒë√∫ng ch√≠nh t·∫£)
        input.addEventListener("focus", function () {
          const query = this.value.trim();
          // Ch·ªâ hi·ªán l·∫°i g·ª£i √Ω n·∫øu c√≥ text v√† ch∆∞a ƒë√∫ng ch√≠nh t·∫£
          if (
            query.length > 0 &&
            !this.classList.contains("correct-spelling")
          ) {
            // Trigger l·∫°i API g·ª£i √Ω
            const event = new Event("input", { bubbles: true });
            this.dispatchEvent(event);
          }
        });

        // Prevent default ƒë·ªÉ kh√¥ng m·∫•t focus khi click suggestion
        suggestionsBox.addEventListener("mousedown", function (event) {
          event.preventDefault();
        });



        // Note: Vietnamese definition will be auto-filled from word translation
        // when user enters correct spelling of the term

        // Function to perform spell check ƒë∆∞·ª£c di chuy·ªÉn ra ngo√†i
      });

      // Debounce function to limit how often a function is called
      function debounce(func, delay) {
        let timeout;
        return function (...args) {
          const context = this;
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(context, args), delay);
        };
      }

      // Image functionality handled by local upload only

      // Global function to translate word to Vietnamese meaning
      function translateWordToVietnamese(word, vietnameseTextarea) {
        if (!word.trim()) {
          vietnameseTextarea.value = "";
          return;
        }

        fetch(
          `/api/translate-word-to-vietnamese/?word=${encodeURIComponent(word)}`
        )
          .then((response) => response.json())
          .then((data) => {
            if (data.error) {
              console.error("Word translation error:", data.error);
              vietnameseTextarea.value = "L·ªói d·ªãch t·ª´: " + data.error;
              vietnameseTextarea.style.color = "#F44336";
            } else {
              vietnameseTextarea.value = data.recommended;
              vietnameseTextarea.style.color = "#ffffff";
              // Add a subtle indication this was auto-translated
              vietnameseTextarea.style.fontStyle = "italic";
              setTimeout(() => {
                vietnameseTextarea.style.fontStyle = "normal";
              }, 2000);
            }
          })
          .catch((error) => {
            console.error("Word translation request failed:", error);
            vietnameseTextarea.value = "L·ªói k·∫øt n·ªëi khi d·ªãch t·ª´";
            vietnameseTextarea.style.color = "#F44336";
          });
      }

      // Global translate function (for sentences/definitions)
      function translateToVietnamese(englishText, vietnameseTextarea) {
        if (!englishText.trim()) {
          vietnameseTextarea.value = "";
          return;
        }

        fetch(
          `/api/translate-to-vietnamese/?text=${encodeURIComponent(
            englishText
          )}`
        )
          .then((response) => response.json())
          .then((data) => {
            if (data.error) {
              console.error("Translation error:", data.error);
              vietnameseTextarea.value = "L·ªói d·ªãch: " + data.error;
              vietnameseTextarea.style.color = "#F44336";
            } else {
              vietnameseTextarea.value = data.translated;
              vietnameseTextarea.style.color = "#ffffff";
            }
          })
          .catch((error) => {
            console.error("Translation request failed:", error);
            vietnameseTextarea.value = "L·ªói k·∫øt n·ªëi khi d·ªãch";
            vietnameseTextarea.style.color = "#F44336";
          });
      }

      // Global checkSpelling function
      function checkSpelling(inputElement) {
        const wordToCheck = inputElement.value.trim();
        if (wordToCheck.length > 0) {
          fetch("/check-spelling/", {
            method: "POST",
            headers: {
              "Content-Type": "application/x-www-form-urlencoded",
              "X-CSRFToken": getCSRFToken(),
            },
            body: `word=${encodeURIComponent(wordToCheck)}`,
          })
            .then((response) => {
              if (!response.ok) {
                return response.json().catch(() => {
                  throw new Error(`HTTP error! status: ${response.status}`);
                });
              }
              return response.json();
            })
            .then((data) => {
              if (data && data.error) {
                console.error(
                  "Backend returned an error for spell check:",
                  data.error
                );
                inputElement.classList.remove(
                  "correct-spelling",
                  "incorrect-spelling"
                );
                return;
              }

              // T√¨m suggestions box t∆∞∆°ng ·ª©ng v·ªõi input n√†y
              const suggestionsBox =
                inputElement.parentNode.querySelector(".suggestions-list");

              if (data.is_correct) {
                inputElement.classList.remove("incorrect-spelling");
                inputElement.classList.add("correct-spelling");
                // ·∫®n g·ª£i √Ω khi t·ª´ ƒë√£ ƒë√∫ng ch√≠nh t·∫£
                if (suggestionsBox) {
                  suggestionsBox.style.display = "none";
                }

                // Auto-translate word to Vietnamese when correct
                const flashcardSection =
                  inputElement.closest(".flashcard-section");
                const vietnameseTextarea = flashcardSection.querySelector(
                  "textarea[name*='vietnamese_definition']"
                );
                if (vietnameseTextarea) {
                  translateWordToVietnamese(wordToCheck, vietnameseTextarea);
                }
              } else {
                inputElement.classList.remove("correct-spelling");
                inputElement.classList.add("incorrect-spelling");

                // Word is incorrect - no special actions needed
              }
            })
            .catch((error) => {
              console.error("Error checking spelling:", error);
              inputElement.classList.remove(
                "correct-spelling",
                "incorrect-spelling"
              );
            });
        }
      }

      // IMAGE UPLOAD LOGIC
      function setupImageUpload(
        imageUploadId,
        fileInputId,
        imgPreviewId,
        deleteBtnId
      ) {
        const imageUpload = document.getElementById(imageUploadId);
        const fileInput = document.getElementById(fileInputId);
        const imgPreview = document.getElementById(imgPreviewId);
        const deleteBtn = document.getElementById(deleteBtnId);
        const uploadContent = imageUpload.querySelector(
          ".image-upload-content"
        );

        imageUpload.addEventListener("click", function (e) {
          // ƒê·ª´ng trigger khi click v√†o n√∫t delete
          if (e.target === deleteBtn) return;
          fileInput.click();
        });

        fileInput.addEventListener("change", function (event) {
          const file = event.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = function (e) {
              imgPreview.src = e.target.result;
              imgPreview.style.display = "block";
              if (uploadContent) uploadContent.style.display = "none";
              if (deleteBtn) deleteBtn.style.display = "block";
            };
            reader.readAsDataURL(file);
          }
        });

        if (deleteBtn) {
          deleteBtn.addEventListener("click", function (e) {
            e.stopPropagation(); // Kh√¥ng trigger upload khi x√≥a
            imgPreview.src = "";
            imgPreview.style.display = "none";
            fileInput.value = "";
            if (uploadContent) uploadContent.style.display = "flex";
            deleteBtn.style.display = "none";
          });
          // ·∫®n n√∫t delete ban ƒë·∫ßu
          deleteBtn.style.display = "none";
        }
      }
      setupImageUpload(
        "imageUpload1",
        "fileInput1",
        "imgPreview1",
        "deleteImg1"
      );

      // ADD FLASHCARD LOGIC
      function reindexFlashcards() {
        const cards = document.querySelectorAll(".flashcard-section");
        cards.forEach((card, idx) => {
          const index = idx + 1;
          card.setAttribute("data-card-index", index);
          card.querySelector(".card-number").textContent = index;
          // Update input ids/names
          card.querySelector(".term-input").id = `term${index}`;
          card.querySelector(".term-input").name = `term${index}`;

          // Update English definition textarea
          const englishTextarea = card.querySelector(
            "textarea[name*='definition']:not([name*='vietnamese'])"
          );
          if (englishTextarea) {
            englishTextarea.id = `definition${index}`;
            englishTextarea.name = `definition${index}`;
          }

          // Update Vietnamese definition textarea
          const vietnameseTextarea = card.querySelector(
            "textarea[name*='vietnamese_definition']"
          );
          if (vietnameseTextarea) {
            vietnameseTextarea.id = `vietnamese_definition${index}`;
            vietnameseTextarea.name = `vietnamese_definition${index}`;
          }

          card.querySelector(".suggestions-list").id = `suggestions${index}`;
          card.querySelector(".image-upload").id = `imageUpload${index}`;
          card.querySelector('input[type="file"]').id = `fileInput${index}`;
          card.querySelector("img.preview").id = `imgPreview${index}`;
          card.querySelector(
            'button[id^="deleteImg"]'
          ).id = `deleteImg${index}`;
        });
      }

      function initFlashcardSection(section) {
        // --- G·ª£i √Ω t·ª´, ki·ªÉm tra ch√≠nh t·∫£, ch·ªçn ƒë·ªãnh nghƒ©a ---
        const input = section.querySelector(".term-input");
        const suggestionsBox = section.querySelector(".suggestions-list");
        const definitionInput = section.querySelector(
          "textarea[name*='definition']:not([name*='vietnamese'])"
        );
        const vietnameseDefinitionInput = section.querySelector(
          "textarea[name*='vietnamese_definition']"
        );
        const cardIndex = section.getAttribute("data-card-index");

        // G·ª£i √Ω t·ª´ v·ªõi logic c·∫£i ti·∫øn
        input.addEventListener(
          "input",
          debounce(function () {
            const query = this.value.trim();
            this.classList.remove("correct-spelling", "incorrect-spelling");

            // Ch·ªâ hi·ªán g·ª£i √Ω khi c√≥ focus v√† t·ª´ ch∆∞a ƒë√∫ng ch√≠nh t·∫£
            if (query.length > 0 && document.activeElement === this) {
              fetch(`/suggest-words/?q=${encodeURIComponent(query)}`)
                .then((response) => {
                  if (!response.ok) {
                    return response.json().catch(() => {
                      throw new Error(`HTTP error! status: ${response.status}`);
                    });
                  }
                  return response.json();
                })
                .then((data) => {
                  // Ki·ªÉm tra l·∫°i: ch·ªâ hi·ªán g·ª£i √Ω n·∫øu v·∫´n focus v√† ch∆∞a ƒë√∫ng ch√≠nh t·∫£
                  if (
                    document.activeElement !== this ||
                    this.classList.contains("correct-spelling")
                  ) {
                    suggestionsBox.style.display = "none";
                    return;
                  }

                  suggestionsBox.innerHTML = "";
                  if (data && data.error) {
                    suggestionsBox.style.display = "none";
                    return;
                  }
                  if (data.length > 0) {
                    data.forEach((word) => {
                      const suggestionItem = document.createElement("div");
                      suggestionItem.classList.add("suggestion-item");
                      suggestionItem.textContent = word;
                      suggestionItem.addEventListener("click", () => {
                        input.value = word;
                        suggestionsBox.style.display = "none";
                        checkSpelling(input);
                        // Auto-fetch first definition directly
                        if (input.value.trim()) {
                          fetch(
                            `/word-details/?word=${encodeURIComponent(
                              input.value.trim()
                            )}`
                          )
                            .then((response) => {
                              if (!response.ok) {
                                return response.json().catch(() => {
                                  throw new Error(
                                    `HTTP error! status: ${response.status}`
                                  );
                                });
                              }
                              return response.json();
                            })
                            .then((data) => {
                              if (data && data.error) {
                                definitionInput.value = `L·ªói: ${data.error}`;
                                definitionInput.style.color = "#F44336";
                                return;
                              }
                              
                              // Get first definition directly
                              let firstDefinition = "";
                              if (data.meanings && data.meanings.length > 0) {
                                const firstMeaning = data.meanings[0];
                                if (firstMeaning.definitions && firstMeaning.definitions.length > 0) {
                                  firstDefinition = firstMeaning.definitions[0].en;
                                }
                              }

                              if (firstDefinition) {
                                definitionInput.value = firstDefinition.trim();
                                definitionInput.style.color = "#ffffff";

                                // Auto-translate to Vietnamese
                                if (vietnameseDefinitionInput) {
                                  translateToVietnamese(firstDefinition.trim(), vietnameseDefinitionInput);
                                }
                              } else {
                                definitionInput.value = "Kh√¥ng t√¨m th·∫•y ƒë·ªãnh nghƒ©a.";
                                definitionInput.style.color = "#b0b0b0";
                              }
                            })
                            .catch((error) => {
                              definitionInput.value = `L·ªói: ${
                                error.message || "Kh√¥ng th·ªÉ l·∫•y ƒë·ªãnh nghƒ©a."
                              }`;
                              definitionInput.style.color = "#F44336";
                            });
                        }
                      });
                      suggestionsBox.appendChild(suggestionItem);
                    });
                    suggestionsBox.style.display = "block";
                  } else {
                    suggestionsBox.style.display = "none";
                  }
                })
                .catch(() => {
                  suggestionsBox.style.display = "none";
                });
              checkSpelling(input);
            } else {
              suggestionsBox.style.display = "none";
              this.classList.remove("correct-spelling", "incorrect-spelling");
            }
          }, 300)
        );

        // Hide suggestions khi blur - ·∫©n ngay l·∫≠p t·ª©c n·∫øu m·∫•t focus
        input.addEventListener("blur", function () {
          // Delay ng·∫Øn ƒë·ªÉ cho ph√©p click v√†o suggestion
          setTimeout(() => {
            // Ki·ªÉm tra n·∫øu kh√¥ng focus v√†o input ho·∫∑c suggestions th√¨ ·∫©n ƒëi
            if (
              document.activeElement !== this &&
              !suggestionsBox.contains(document.activeElement)
            ) {
              suggestionsBox.style.display = "none";
            }
          }, 150);
        });

        // Show suggestions khi focus l·∫°i (n·∫øu t·ª´ ch∆∞a ƒë√∫ng ch√≠nh t·∫£)
        input.addEventListener("focus", function () {
          const query = this.value.trim();
          // Ch·ªâ hi·ªán l·∫°i g·ª£i √Ω n·∫øu c√≥ text v√† ch∆∞a ƒë√∫ng ch√≠nh t·∫£
          if (
            query.length > 0 &&
            !this.classList.contains("correct-spelling")
          ) {
            // Trigger l·∫°i API g·ª£i √Ω
            const event = new Event("input", { bubbles: true });
            this.dispatchEvent(event);
          }
        });

        // Prevent default ƒë·ªÉ kh√¥ng m·∫•t focus khi click suggestion
        suggestionsBox.addEventListener("mousedown", function (event) {
          event.preventDefault();
        });



        // Note: Vietnamese definition will be auto-filled from word translation
        // when user enters correct spelling of the term

        // S·ª≠ d·ª•ng function checkSpelling global
      }

      // Khi load trang, kh·ªüi t·∫°o cho th·∫ª ƒë·∫ßu ti√™n
      document
        .querySelectorAll(".flashcard-section")
        .forEach(initFlashcardSection);

      // Khi th√™m th·∫ª m·ªõi
      function addFlashcard() {
        const container = document.getElementById("flashcard-container");
        const cards = container.querySelectorAll(".flashcard-section");
        const newIndex = cards.length + 1;
        const template = cards[0].cloneNode(true);
        // Reset input values
        template.querySelector(".term-input").value = "";
        template.querySelector(
          "textarea[name*='definition']:not([name*='vietnamese'])"
        ).value = "";
        template.querySelector(
          "textarea[name*='vietnamese_definition']"
        ).value = "";
        template.querySelector("img.preview").src = "";
        template.querySelector("img.preview").style.display = "none";
        template.querySelector('input[type="file"]').value = "";
        template.querySelector(".image-upload-content").style.display = "flex";
        template.querySelector('button[id^="deleteImg"]').style.display =
          "none";
        template.querySelector(".suggestions-list").innerHTML = "";
        template.querySelector(".suggestions-list").style.display = "none";
        // Clear definition suggestions for new card
        template.querySelector(".definition-suggestions").innerHTML = "";
        template.querySelector(".definition-suggestions").style.display =
          "none";
        container.appendChild(template);
        reindexFlashcards();
        initFlashcardSection(template);
        attachWordExistsCheck(template.querySelector(".term-input"));
        attachDefinitionSuggestionLogic(template);
        attachSpeakIconLogic(template);
        attachAutoInfoLogic(template);
        attachClearFieldsOnTermChange(template);
        // G·∫Øn logic x√≥a cho th·∫ª m·ªõi
        attachDeleteCardLogicForSingleCard(template);
      }
      document
        .querySelector(".button-group .button")
        .addEventListener("click", function (e) {
          if (this.textContent.trim() === "Th√™m th·∫ª") {
            e.preventDefault();
            addFlashcard();
          }
        });

      // Kh·ªüi t·∫°o SortableJS cho container v·ªõi handle
      const flashcardContainer = document.getElementById("flashcard-container");
      new Sortable(flashcardContainer, {
        animation: 200,
        handle: ".drag-handle", // Ch·ªâ cho ph√©p k√©o khi click v√†o n√∫t drag handle
        onEnd: function (evt) {
          reindexFlashcards();
        },
      });

      // Bi·∫øn cache l∆∞u d·ªØ li·ªáu API t·ª´ng t·ª´
      const wordApiCache = {};

      // Khi fetch chi ti·∫øt t·ª´ (v√≠ d·ª• trong logic autocomplete, enter...), l∆∞u v√†o cache
      function fetchWordDetailsAndCache(word, callback) {
        fetch(`/word-details/?word=${encodeURIComponent(word)}`)
          .then((res) => res.json())
          .then((data) => {
            wordApiCache[word.toLowerCase()] = data;
            if (callback) callback(data);
          });
      }

      document
        .getElementById("saveAllFlashcardsBtn")
        .addEventListener("click", function (e) {
          e.preventDefault();
          const cards = document.querySelectorAll(".flashcard-section");
          const formData = new FormData();
          cards.forEach((card, idx) => {
            const termInput = card.querySelector(".term-input");
            let word = termInput ? termInput.value.trim() : "";
            formData.append(`flashcards[${idx}][word]`, word);

            let posInput = card.querySelector(".part-of-speech-input");
            let part_of_speech = posInput ? posInput.value.trim() : "";

            let defTextarea = card.querySelector(
              "textarea[name*='definition']:not([name*='vietnamese'])"
            );
            let english_definition = defTextarea
              ? defTextarea.value.trim()
              : "";

            let vietnameseDefTextarea = card.querySelector(
              "textarea[name*='vietnamese_definition']"
            );
            let vietnamese_definition = vietnameseDefTextarea
              ? vietnameseDefTextarea.value.trim()
              : "";

            let audioInput = card.querySelector(".audio-url-input");
            let audio_url = audioInput ? audioInput.value.trim() : "";

            // N·∫øu thi·∫øu lo·∫°i t·ª´ ho·∫∑c audio_url th√¨ l·∫•y t·ª´ cache
            const cache = wordApiCache[word.toLowerCase()];
            if (cache) {
              if (!part_of_speech && cache.meanings && cache.meanings[0]) {
                part_of_speech = cache.meanings[0].part_of_speech || "";
              }
              if (!audio_url && cache.phonetics && cache.phonetics.length > 0) {
                // L·∫•y audio ƒë·∫ßu ti√™n c√≥ gi√° tr·ªã
                for (let ph of cache.phonetics) {
                  if (ph.audio) {
                    audio_url = ph.audio;
                    break;
                  }
                }
              }
            }
            formData.append(
              `flashcards[${idx}][part_of_speech]`,
              part_of_speech
            );
            formData.append(
              `flashcards[${idx}][english_definition]`,
              english_definition
            );
            formData.append(
              `flashcards[${idx}][vietnamese_definition]`,
              vietnamese_definition
            );
            formData.append(`flashcards[${idx}][audio_url]`, audio_url);

            const imgInput = card.querySelector('input[type="file"]');
            if (imgInput && imgInput.files && imgInput.files[0]) {
              formData.append(`flashcards[${idx}][image]`, imgInput.files[0]);
            }
          });
          fetch("/api/save-flashcards/", {
            method: "POST",
            headers: {
              "X-CSRFToken": getCSRFToken(),
            },
            body: formData,
          })
            .then((res) => res.json())
            .then((data) => {
              if (data.success) {
                alert("L∆∞u th√†nh c√¥ng!");
              } else {
                alert("L·ªói: " + (data.error || "Kh√¥ng l∆∞u ƒë∆∞·ª£c!"));
              }
            })
            .catch((err) => {
              alert("L·ªói k·∫øt n·ªëi server!");
            });
        });

      function showWordExistsError(input, show) {
        let err = input.parentNode.querySelector(".word-exists-error");
        if (!err && show) {
          err = document.createElement("div");
          err.className = "word-exists-error";
          err.style.color = "#ff5252";
          err.style.fontSize = "0.95em";
          err.style.marginTop = "4px";
          err.textContent = "T·ª´ n√†y ƒë√£ t·ªìn t·∫°i trong h·ªá th·ªëng!";
          input.parentNode.appendChild(err);
        }
        if (err) err.style.display = show ? "block" : "none";
        input.style.borderColor = show ? "#ff5252" : "";
      }

      function attachWordExistsCheck(input) {
        input.addEventListener(
          "input",
          debounce(function () {
            const word = this.value.trim();
            if (!word) {
              showWordExistsError(this, false);
              return;
            }
            fetch(`/api/check-word-exists/?word=${encodeURIComponent(word)}`)
              .then((res) => res.json())
              .then((data) => {
                showWordExistsError(this, data.exists);
              });
          }, 300)
        );
      }

      document.querySelectorAll(".term-input").forEach(attachWordExistsCheck);

      function attachDefinitionSuggestionLogic(section) {
        const termInput = section.querySelector(".term-input");
        const defTextarea = section.querySelector("textarea");
        const suggestionBox = section.querySelector(".definition-suggestions");
        let currentSuggestions = [];
        let suggestionVisible = false;

        // Helper: ki·ªÉm tra ch√≠nh t·∫£ (d·ª±a v√†o class correct-spelling)
        function isTermCorrect() {
          return termInput.classList.contains("correct-spelling");
        }

        // Hi·ªÉn th·ªã g·ª£i √Ω ƒë·ªãnh nghƒ©a
        function showSuggestions(defs) {
          suggestionBox.innerHTML = "";
          if (!defs || defs.length === 0) {
            suggestionBox.style.display = "none";
            suggestionVisible = false;
            return;
          }
          defs.forEach((item) => {
            const div = document.createElement("div");
            div.className = "definition-suggestion-item";
            div.innerHTML =
              (item.part_of_speech
                ? `<span style="color:#b0b0ff;font-style:italic;">(${item.part_of_speech})</span> `
                : "") + item.en;
            div.addEventListener("mousedown", function (e) {
              e.preventDefault();
              defTextarea.value = item.en;
              suggestionBox.style.display = "none";
              suggestionVisible = false;
              
              // Trigger auto-info update sau khi ch·ªçn definition
              const autoInfoUpdateEvent = new Event('input', { bubbles: true });
              defTextarea.dispatchEvent(autoInfoUpdateEvent);
              
              // Also trigger change event to ensure all handlers are called
              const changeEvent = new Event('change', { bubbles: true });
              defTextarea.dispatchEvent(changeEvent);
            });
            suggestionBox.appendChild(div);
          });
          suggestionBox.style.display = "block";
          suggestionVisible = true;
        }

        // Khi focus v√†o textarea ƒë·ªãnh nghƒ©a
        defTextarea.addEventListener("focus", function () {
          if (!isTermCorrect()) {
            suggestionBox.style.display = "none";
            suggestionVisible = false;
            return;
          }
          const word = termInput.value.trim();
          if (!word) return;
          // L·∫•y t·ª´ cache n·∫øu c√≥
          const cache = wordApiCache[word.toLowerCase()];
          if (cache && cache.meanings) {
            let defs = [];
            cache.meanings.forEach((m) => {
              if (m.definitions && m.definitions.length > 0) {
                m.definitions.forEach((d) => {
                  defs.push({
                    en: d.en,
                    part_of_speech: m.part_of_speech || "",
                  });
                });
              }
            });
            showSuggestions(defs);
          } else {
            // N·∫øu ch∆∞a c√≥ cache, fetch v√† cache l·∫°i
            fetchWordDetailsAndCache(word, function (data) {
              let defs = [];
              if (data && data.meanings) {
                data.meanings.forEach((m) => {
                  if (m.definitions && m.definitions.length > 0) {
                    m.definitions.forEach((d) => {
                      defs.push({
                        en: d.en,
                        part_of_speech: m.part_of_speech || "",
                      });
                    });
                  }
                });
              }
              showSuggestions(defs);
            });
          }
        });
        // ·∫®n suggestion khi blur textarea (delay ƒë·ªÉ b·∫Øt s·ª± ki·ªán click ch·ªçn)
        defTextarea.addEventListener("blur", function () {
          setTimeout(() => {
            suggestionBox.style.display = "none";
            suggestionVisible = false;
          }, 200);
        });
      }

      function attachSpeakIconLogic(section) {
        const termInput = section.querySelector(".term-input");
        const defTextarea = section.querySelector("textarea");
        const speakIcon = section.querySelector(".speak-icon");
        if (!speakIcon) return;
        // Hi·ªán/·∫©n icon loa
        function updateSpeakIcon() {
          const word = termInput.value.trim();
          const definition = defTextarea.value.trim();
          if (
            word &&
            definition &&
            termInput.classList.contains("correct-spelling")
          ) {
            speakIcon.style.display = "inline-block";
          } else {
            speakIcon.style.display = "none";
          }
        }
        termInput.addEventListener("input", updateSpeakIcon);
        defTextarea.addEventListener("input", updateSpeakIcon);
        termInput.addEventListener("blur", updateSpeakIcon);
        termInput.addEventListener("change", updateSpeakIcon);
        defTextarea.addEventListener("blur", updateSpeakIcon);
        // X·ª≠ l√Ω khi b·∫•m icon loa
        speakIcon.addEventListener("click", function () {
          const word = termInput.value.trim();
          if (!word) return;
          const cache = wordApiCache[word.toLowerCase()];
          let audioUrl = "";
          let partOfSpeech = "";
          let phonetic = "";
          if (cache) {
            // L·∫•y audio ƒë·∫ßu ti√™n c√≥ gi√° tr·ªã
            if (cache.phonetics && cache.phonetics.length > 0) {
              for (let ph of cache.phonetics) {
                if (ph.audio) {
                  audioUrl = ph.audio;
                  break;
                }
              }
              for (let ph of cache.phonetics) {
                if (ph.text) {
                  phonetic = ph.text;
                  break;
                }
              }
            }
            if (cache.meanings && cache.meanings.length > 0) {
              partOfSpeech = cache.meanings[0].part_of_speech || "";
            }
          }
          if (audioUrl) {
            const audio = new Audio(audioUrl);
            audio.play();
          } else {
            // ƒê·ªçc b·∫±ng Web Speech API
            let text = word;
            if (partOfSpeech) text += ", " + partOfSpeech;
            if (phonetic) text += ", " + phonetic;
            if ("speechSynthesis" in window) {
              const utter = new SpeechSynthesisUtterance(text);
              utter.lang = "en-US";
              window.speechSynthesis.speak(utter);
            } else {
              alert("Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ ƒë·ªçc t·ª´!");
            }
          }
        });
        // L·∫ßn ƒë·∫ßu ki·ªÉm tra
        updateSpeakIcon();
      }

      function attachAutoInfoLogic(section) {
        const termInput = section.querySelector(".term-input");
        const defTextarea = section.querySelector("textarea");
        const autoInfo = section.querySelector(".auto-info");
        const autoPos = section.querySelector(".auto-pos");
        const autoAudio = section.querySelector(".auto-audio");
        function updateAutoInfo() {
          const word = termInput.value.trim();
          const definition = defTextarea.value.trim();
          if (
            word &&
            definition &&
            termInput.classList.contains("correct-spelling")
          ) {
            const cache = wordApiCache[word.toLowerCase()];
            let partOfSpeech = "";
            let audioUrl = "";
            let phonetic = "";
            if (cache) {
              if (cache.meanings && cache.meanings.length > 0) {
                partOfSpeech = cache.meanings[0].part_of_speech || "";
              }
              if (cache.phonetics && cache.phonetics.length > 0) {
                for (let ph of cache.phonetics) {
                  if (ph.audio) {
                    audioUrl = ph.audio;
                    break;
                  }
                }
                for (let ph of cache.phonetics) {
                  if (ph.text) {
                    phonetic = ph.text;
                    break;
                  }
                }
              }
            }
            autoPos.textContent = partOfSpeech
              ? `Lo·∫°i t·ª´: ${partOfSpeech}`
              : "";
            if (audioUrl) {
              autoAudio.innerHTML = `<svg width='22' height='22' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polygon points='11 5 6 9 2 9 2 15 6 15 11 19 11 5'></polygon><path d='M19.07 4.93a10 10 0 0 1 0 14.14'></path><path d='M15.54 8.46a5 5 0 0 1 0 7.07'></path></svg>`;
              autoAudio.title = "Nghe ph√°t √¢m";
              autoAudio.onclick = function () {
                const audio = new Audio(audioUrl);
                audio.play();
              };
            } else if (word) {
              autoAudio.innerHTML = `<svg width='22' height='22' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polygon points='11 5 6 9 2 9 2 15 6 15 11 19 11 5'></polygon><path d='M19.07 4.93a10 10 0 0 1 0 14.14'></path><path d='M15.54 8.46a5 5 0 0 1 0 7.07'></path></svg>`;
              autoAudio.title = "ƒê·ªçc t·ª´ b·∫±ng tr√¨nh duy·ªát";
              autoAudio.onclick = function () {
                let text = word;
                if (partOfSpeech) text += ", " + partOfSpeech;
                if (phonetic) text += ", " + phonetic;
                if ("speechSynthesis" in window) {
                  const utter = new SpeechSynthesisUtterance(text);
                  utter.lang = "en-US";
                  window.speechSynthesis.speak(utter);
                } else {
                  alert("Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ ƒë·ªçc t·ª´!");
                }
              };
            } else {
              autoAudio.innerHTML = "";
              autoAudio.onclick = null;
            }
            autoInfo.style.display =
              partOfSpeech || audioUrl ? "block" : "none";
          } else {
            autoInfo.style.display = "none";
          }
        }
        termInput.addEventListener("input", updateAutoInfo);
        defTextarea.addEventListener("input", updateAutoInfo);
        termInput.addEventListener("blur", updateAutoInfo);
        termInput.addEventListener("change", updateAutoInfo);
        defTextarea.addEventListener("blur", updateAutoInfo);
        updateAutoInfo();
      }

      // Function ƒë·ªÉ clear t·∫•t c·∫£ fields khi thay ƒë·ªïi term
      function attachClearFieldsOnTermChange(section) {
        const termInput = section.querySelector(".term-input");
        const englishDefTextarea = section.querySelector("textarea[name*='definition']:not([name*='vietnamese'])");
        const vietnameseDefTextarea = section.querySelector("textarea[name*='vietnamese_definition']");
        const imageUpload = section.querySelector(".image-upload");
        const imageInput = section.querySelector('input[type="file"]');
        const autoInfo = section.querySelector(".auto-info");
        const audioInput = section.querySelector(".audio-url-input");
        
        let previousValue = termInput.value.trim();
        
        function clearAllFields() {
          // Clear definition textareas
          if (englishDefTextarea) englishDefTextarea.value = "";
          if (vietnameseDefTextarea) vietnameseDefTextarea.value = "";
          
          // Clear audio URL
          if (audioInput) audioInput.value = "";
          
          // Clear image upload
          if (imageInput) {
            imageInput.value = "";
            // Remove image preview if exists
            const existingPreview = imageUpload.querySelector("img.preview");
            if (existingPreview) {
              existingPreview.remove();
            }
            // Reset upload area text
            if (imageUpload) {
              imageUpload.innerHTML = `
                <div>üì∑</div>
                <div>Ch·ªçn ·∫£nh</div>
              `;
            }
          }
          
          // Hide auto info
          if (autoInfo) autoInfo.style.display = "none";
        }
        
        termInput.addEventListener("input", function() {
          const currentValue = this.value.trim();
          
          // Only clear if the term actually changed (not just whitespace)
          if (previousValue && currentValue !== previousValue) {
            clearAllFields();
          }
          
          previousValue = currentValue;
        });
      }

      // Khi load trang, g·∫Øn logic cho t·∫•t c·∫£ th·∫ª
      setTimeout(() => {
        document
          .querySelectorAll(".flashcard-section")
          .forEach(attachDefinitionSuggestionLogic);
        document
          .querySelectorAll(".flashcard-section")
          .forEach(attachSpeakIconLogic);
        document
          .querySelectorAll(".flashcard-section")
          .forEach(attachAutoInfoLogic);
        document
          .querySelectorAll(".flashcard-section")
          .forEach(attachClearFieldsOnTermChange);
        attachDeleteCardLogic(); // Th√™m logic x√≥a th·∫ª
      }, 0);
    });

    // X·ª≠ l√Ω ch·ª©c nƒÉng x√≥a th·∫ª
    function attachDeleteCardLogic() {
      document.querySelectorAll(".delete-card-btn").forEach((btn) => {
        btn.addEventListener("click", function (e) {
          e.preventDefault();
          e.stopPropagation();

          const flashcardSection = this.closest(".flashcard-section");
          const totalCards =
            document.querySelectorAll(".flashcard-section").length;

          // Kh√¥ng cho ph√©p x√≥a n·∫øu ch·ªâ c√≤n 1 th·∫ª
          if (totalCards <= 1) {
            alert("Kh√¥ng th·ªÉ x√≥a th·∫ª cu·ªëi c√πng. Ph·∫£i c√≥ √≠t nh·∫•t 1 th·∫ª.");
            return;
          }

          // Animation x√≥a ngay l·∫≠p t·ª©c
          flashcardSection.style.transform = "scale(0.8)";
          flashcardSection.style.opacity = "0";
          flashcardSection.style.transition = "all 0.3s ease";

          setTimeout(() => {
            flashcardSection.remove();
            reindexFlashcards(); // C·∫≠p nh·∫≠t l·∫°i s·ªë th·ª© t·ª± th·∫ª
          }, 300);
        });
      });
    }

    // X·ª≠ l√Ω ch·ª©c nƒÉng x√≥a th·∫ª cho m·ªôt th·∫ª c·ª• th·ªÉ (d√πng khi th√™m th·∫ª m·ªõi)
    function attachDeleteCardLogicForSingleCard(section) {
      const deleteBtn = section.querySelector(".delete-card-btn");
      if (deleteBtn) {
        deleteBtn.addEventListener("click", function (e) {
          e.preventDefault();
          e.stopPropagation();

          const flashcardSection = this.closest(".flashcard-section");
          const totalCards =
            document.querySelectorAll(".flashcard-section").length;

          // Kh√¥ng cho ph√©p x√≥a n·∫øu ch·ªâ c√≤n 1 th·∫ª
          if (totalCards <= 1) {
            alert("Kh√¥ng th·ªÉ x√≥a th·∫ª cu·ªëi c√πng. Ph·∫£i c√≥ √≠t nh·∫•t 1 th·∫ª.");
            return;
          }

          // Animation x√≥a ngay l·∫≠p t·ª©c
          flashcardSection.style.transform = "scale(0.8)";
          flashcardSection.style.opacity = "0";
          flashcardSection.style.transition = "all 0.3s ease";

          setTimeout(() => {
            flashcardSection.remove();
            reindexFlashcards(); // C·∫≠p nh·∫≠t l·∫°i s·ªë th·ª© t·ª± th·∫ª
          }, 300);
        });
      }
    }

    function getCookie(name) {
      let cookieValue = null;
      if (document.cookie && document.cookie !== "") {
        const cookies = document.cookie.split(";");
        for (let i = 0; i < cookies.length; i++) {
          const cookie = cookies[i].trim();
          if (cookie.substring(0, name.length + 1) === name + "=") {
            cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
            break;
          }
        }
      }
      return cookieValue;
    }

    // Function to get CSRF token from multiple sources
    function getCSRFToken() {
      // First try to get from cookie
      let token = getCookie("csrftoken");
      if (token) return token;

      // Try to get from DOM element
      const csrfElement = document.querySelector("[name=csrfmiddlewaretoken]");
      if (csrfElement) return csrfElement.value;

      // Try to get from meta tag
      const metaElement = document.querySelector("meta[name=csrf-token]");
      if (metaElement) return metaElement.getAttribute("content");

      console.warn("CSRF token not found");
      return "";
    }
  </script>
</div>
{% endblock %}
